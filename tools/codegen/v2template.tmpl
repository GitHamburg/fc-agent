//nolint:golint
package v2


// Generated by tool/codegen to add a new integration add to tools/codegen/registry, then run make generate

import (
    "context"
    "errors"
    "fmt"
    "net/http"

    "github.com/go-kit/log"
    "github.com/grafana/agent/pkg/integrations/shared"
    "github.com/grafana/agent/pkg/integrations/v2/common"
    "gopkg.in/yaml.v2"
    "github.com/prometheus/client_golang/prometheus/promhttp"

{{ range $element := . -}}
    "{{ $element.PackagePath}}"
{{ end -}}
)

// Integrations is a wrapper to hold all the integrations for marshalling
type Integrations struct {
{{ range $index, $element := . -}}
    {{ if eq .Type 0 -}}
        {{ $element.Name }} *{{$element.Name}} `yaml:"{{ $element.PackageName }},omitempty"`
    {{ end -}}
    {{ if eq .Type  1 -}}
        {{ $element.Name }}Configs []*{{$element.Name}} `yaml:"{{ $element.PackageName }}_configs,omitempty"`
    {{ end -}}
{{ end -}}
TestConfigs []Config `yaml:"-,omitempty"`
}

// ActiveConfigs returns an array of integrations that have been set
func (v *Integrations) ActiveConfigs() []Config {
activeConfigs := make([]Config,0)
{{ range $index, $element := . -}}
    {{ if eq .Type  0 -}}
        if v.{{ $element.Name }} != nil {
        {{ if $element.IsV1 -}}
            activeConfigs = append(activeConfigs, newConfigWrapper(v.{{ $element.Name}}, v.{{ $element.Name}}.Cmn, v.{{ $element.Name}}.NewIntegration, v.{{ $element.Name}}.InstanceKey))
        {{ else  -}}
            activeConfigs = append(activeConfigs, v.{{ $element.Name }})
        {{ end -}}
        }
    {{ end -}}
    {{ if eq .Type  1 -}}
        for _, i := range v.{{ $element.Name}}Configs {
        {{ if $element.IsV1 -}}
            activeConfigs = append(activeConfigs, newConfigWrapper(i, i.Cmn, i.NewIntegration, i.InstanceKey))
        {{ else  -}}
            activeConfigs = append(activeConfigs, i.Config)
        {{ end -}}

        }
    {{ end -}}
{{ end -}}
        activeConfigs = append(activeConfigs, v.TestConfigs...)

        return activeConfigs
}

{{ range $element := . -}}

type {{ $element.Name }} struct {
    {{.ConfigStruct}} `yaml:",omitempty,inline"`

    {{ if $element.IsV1 -}}
    Cmn common.MetricsConfig  `yaml:",inline"`
    {{ end -}}
}

// UnmarshalYaml is required for unmarshalling
func (c *{{ $element.Name }}) UnmarshalYAML(unmarshal func(interface{}) error) error {
    {{ if $element.DefaultConfig -}}
    c.Config = {{ .PackageName }}.DefaultConfig
    {{ end -}}
    err := implementsMarshaller(c.Config)
    if err != nil {
        return err
    }
    type plain {{ .Name }}
    return unmarshal((*plain)(c))
}
    {{ if eq $element.IsV1 false -}}
func (c *{{ $element.Name }}) NewIntegration(l log.Logger, globals shared.Globals) (Integration, error) {
        return NewMetricsHandlerIntegration(l,c,c.Common,globals, promhttp.Handler())
}
    {{end -}}
{{ end -}}

type configWrapper struct {
    cfg                shared.Config
    cmn                common.MetricsConfig
    configInstanceFunc configInstance
    newInstanceFunc    newIntegration
}

func (c *configWrapper) ApplyDefaults(globals shared.Globals) error {
    c.cmn.ApplyDefaults(globals.Autoscrape)
    if id, err := c.Identifier(globals); err == nil {
        c.cmn.InstanceKey = &id
    }
    return nil
}

func (c *configWrapper) Identifier(globals shared.Globals) (string, error) {
    if c.cmn.InstanceKey != nil {
        return *c.cmn.InstanceKey, nil
    }
    return c.configInstanceFunc(globals.AgentIdentifier)
}

func (c *configWrapper) NewIntegration(logger log.Logger, globals shared.Globals) (Integration, error) {
    return newIntegrationFromV1(c, logger, globals, c.newInstanceFunc)
}

func (c *configWrapper) Cfg() Config {
    return c
}

func (c *configWrapper) Name() string {
    return c.cfg.Name()
}

func (c *configWrapper) Common() common.MetricsConfig {
    return c.cmn
}

type newIntegration func(l log.Logger) (shared.Integration, error)

type configInstance func(agentKey string) (string, error)

func newConfigWrapper(cfg shared.Config, cmn common.MetricsConfig, ni newIntegration, ci configInstance) *configWrapper {
    return &configWrapper{
        cfg:                cfg,
        cmn:                cmn,
        configInstanceFunc: ci,
        newInstanceFunc:    ni,
    }
}

func newIntegrationFromV1(c integrationConfig, logger log.Logger, globals shared.Globals, newInt func(l log.Logger) (shared.Integration, error)) (Integration, error) {

    v1Integration, err := newInt(logger)
    if err != nil {
        return nil, err
    }

    id, err := c.Cfg().Identifier(globals)
    if err != nil {
        return nil, err
    }

    // Generate our handler. Original integrations didn't accept a prefix, and
    // just assumed that they would be wired to /metrics somewhere.
    handler, err := v1Integration.MetricsHandler()
    if err != nil {
        return nil, fmt.Errorf("generating http handler: %w", err)
    } else if handler == nil {
        handler = http.NotFoundHandler()
    }

    // Generate targets. Original integrations used a static set of targets,
    // so this mapping can always be generated just once.
    //
    // Targets are generated from the result of ScrapeConfigs(), which returns a
    // tuple of job name and relative metrics path.
    //
    // Job names were prefixed at the subsystem level with integrations/, so we
    // will retain that behavior here.
    v1ScrapeConfigs := v1Integration.ScrapeConfigs()
    targets := make([]handlerTarget, 0, len(v1ScrapeConfigs))
        for _, sc := range v1ScrapeConfigs {
            targets = append(targets, handlerTarget{
            MetricsPath: sc.MetricsPath,
            Labels: model.LabelSet{
            model.JobLabel: model.LabelValue("integrations/" + sc.JobName),
            },
        })
    }

    // Convert he run function. Original integrations sometimes returned
    // ctx.Err() on exit. This isn't recommended anymore, but we need to hide the
    // error if it happens, since the error was previously ignored.
    runFunc := func(ctx context.Context) error {
    err := v1Integration.Run(ctx)
    switch {
        case err == nil:
            return nil
        case errors.Is(err, context.Canceled) && ctx.Err() != nil:
        // Hide error that no longer happens in newer integrations.
            return nil
        default:
            return err
    }
    }

    // Aggregate our converted settings into a v2 integration.
    return &metricsHandlerIntegration{
        integrationName: c.Cfg().Name(),
        instanceID:      id,

        common:         c.Common(),
        globals:        globals,
        handler:    handler,
        targets: targets,

        runFunc: runFunc,
        }, nil
    }

func implementsMarshaller(i interface{}) error {
    _, ok := i.(yaml.Unmarshaler)
    if ok {
        return fmt.Errorf("%T cannot implement custom unmarshaler", i)
    }
    return nil
}

type integrationConfig interface {
    Cfg() Config
    Common() common.MetricsConfig
}